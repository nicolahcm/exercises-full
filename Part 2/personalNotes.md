
##################################Ã        PART A


1) Using jsx in lists:

notes.map(note => <li>{note.content}</li>)


WHEN RENDERING COLLECTIONS
2) React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered. 
So in the example above we should have used a key!



3) Map method:
notes.map((note, index) => ...)     // second parameter is index!


4) React code structure: 
Components folder inside "src"


5) Pro tip: debugging:


const App = () => {
  const course = {
    // ...
  }

  console.log('App works...')          //// HEREEEE

  return (
    // ..
  )
}



#########################                         PART B  (forms and controlled components)



1) A Form input controlled: set the value to a fixed state. You cannot change the input! Unless...
1.5) A handler event.  Read this https://reactjs.org/docs/forms.html#controlled-components
This link also has 2 examples of html tags: "select" and "textarea"

3) passing from notes to notesToShow.... Just rename the variable notes to notesToShow and define notesToShow as...









#################                             PART C (communicating with servers)


1) There is a fake db: https://github.com/typicode/json-server 

Check it for future knowledge on how to make query strings etc.. read README.md


@TO DO@TO DO@TO DO@TO DO
2) Check 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop
and 
https://en.wikipedia.org/wiki/Input/output

"Currently, JavaScript engines are single-threaded, which means that they cannot execute code in parallel. As a result, it is a requirement in practice to use a non-blocking model for executing IO operations. Otherwise, the browser would "freeze" during, for instance, the fetching of data from a server."


See better this part of event loop. Other links in the site.

3) Axios ...

4) The Effect Hook lets you perform side effects in function components. Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.

Example of code:

import React, {useState, useEffect} from 'react'

const App = () => {
  const [notes, setNotes] = useState([])

  useEffect(() => {
    console.log('effect')
    axios
      .get('http://localhost:3001/notes')
      .then(response => {
        console.log('promise fulfilled')
        setNotes(response.data)
      })
  }, [])

  console.log('render', notes.length, 'notes')
  .....
}


5) By default, effects run AFTER every completed render, but you can choose to fire it only when certain values have changed.

So by default the effect is always run after the component has been rendered. In our case, however, we only want to execute the effect along with the first render.

The second parameter of useEffect is used to specify how often the effect is run. If the second parameter is an empty array [], then the effect is only run along with the first render of the component.


6) Understand the order of execution!
7) Read useEffect on React.  ---> Plus see my exercise. There is some useful notes on how to understand the order of execution.

USEEFFECT: MEMORIZE THE FOLLOWING
 
8) "Effect after every render", 
where effect is the function. We can customize after which render.



9) See https://www.youtube.com/watch?v=TNhaISOUy6Q&list=WL&index=256&t=61s
Use hooks on top of components!




##########################           PART D: Altering data in server.

1) REST is a protocol. We should follow the "rules" set. For example /notes/4 where 4 is the id.

2) Let the id be generated from the server when posting a new object.


3) Changing only an element in the list (notes):

notes.map(note => note.id !== id ? note : response.data)

4) Do not change the state even internal items (e.g. state is an array and we try to modify internal elements of the array):
" the variable note is a reference to an item in the notes array in the component's state, and as we recall we must never mutate state directly in React. "


5) Spread operator makes a shallow copy... Only deep if the values are not nested data. 



6) STRUCTURE: COmmunication with backend:
Let's create a directory src/services. Here we create a file (or module) notes.js that handles the notes in its route/routes.


import axios from 'axios'
const baseUrl = 'http://localhost:3001/notes'

const getAll = () => {
  return axios.get(baseUrl)
}

const create = newObject => {
  return axios.post(baseUrl, newObject)
}

const update = (id, newObject) => {
  return axios.put(`${baseUrl}/${id}`, newObject)
}

export default { 
  getAll: getAll, 
  create: create, 
  update: update 
}

-------------------------
AND we import it as :
-
import noteService from './services/notes.js'


7) 
--> get all notes ->>> Put it with useEffect
--> add new note (or modify)->>> without useEfffect. it's enough changing state.


@@@ TO DO TO DO
8) Some good resources TO READ IN FUTURE
The "Async and performance" book from the You do not know JS book series explains the topic well, but the explanation is many pages long.









#################             PART E: Adding style to react app

1) import './index.css'



2) See improved error msg example. Very instructive!
2.1) return null -> for rendering nothing.
2.2) conditional rendering if msg passed is an error.
2.3) set error as state "errorMessage, setErrorMessage". in App.
2.3.1) Create a child component "Notification" (child of App) for the error.
2.4) When error (in a chain of promise, inside the catch, we write this function..). We write a function (inside catch) that takes the error and pass set it setErrorMessage. Therefore the state changes ---> rerender the individual error.
2.5) set also a setTimeout to make the notification disappear: setErrorMessage to no error.